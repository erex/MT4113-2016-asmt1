# I confirm that the attatched is my own work, except where clearly indicated in
# the text.

# Purpose: 
#         Generate n normally distributed random numbers using the 
#         Marsaglia and Bray's method
#
# Input:
#       n - an even integer for the number of desired random numbers
#       mean - a scalar for the desired mean, default 0
#       sd - a positive scalar for the desired standard deviation, default 1
#
# Output:
#      A vector of length n containing the normally distributed random numbers 
#      generated by the method

my.rnorm=function(n,mean=NULL,sd=NULL) {
  if (is.null(mean)) {
    mean <- 0 
  }
  if (is.null(sd)) {
    sd <- 1
  }
  if (length(n)!= 1) {
    stop("invalid arguments")
  }
  if (length(mean)!= 1) {
    stop("invalid arguments")
  }
  if (length(sd) != 1) {
    stop("invalid arguments")
  }
  if (sd <= 0) {
   stop("invalid arguments")
  }
  n_reps <- n/2
  if (!(n_reps == round(n_reps))) {
    stop("invalid arguments")
  }
  list_1 <- c()
  list_2 <- c()
  while (length(list_1) < n) {
    a <- runif(2)
    for (i in 1:2) {
      a[i] <- 2*a[i] - 1
    }
    w <- a[1]^2 + a[2]^2 
    if (w <= 1) {
      v <- sqrt((-2*log(w))/w)
      list_1 <- c(list_1,a)
      list_2 <- c(list_2,v)
    }
  }
  list_1[1] <- list_1[1] * list_2[1]
  for (i in 2:n) {
    list_1[i] <- list_1[i] * list_2[floor(i/2)]
  }
  if (sd != 1) {
    list_1 <- list_1 * sd
  }
  if (mean != 0) {
    list_1 <- list_1 + mean
  }
  return(list_1)
}

# Purpose: 
#          General function to generate n normally distributed random numbers 
#          using 1 of 3 methods
#
# Input:
#       n - an even integer for the number of desired random numbers
#       mean -  a scalar for the desired mean, default 0
#       sd - a positive scalar for the desired standard deviation, default 1
#       method - Integer between 1 and 3 for the method to be used:
#                1 - Marsaglia and Bray's method
#                2 - Box-Mueller algorithm
#                3 - Centeral limit theorem
#                default method is 1 - Marsaglia and Bray's method
#
# Output:
#      A vector of length n containing the normally distributed random numbers 
#      generated using the specified method.

general.rnorm=function(n,mean=NULL,sd=NULL,method=NULL) {
  if (is.null(method)) {
    method <- 1
  }
  if (is.null(mean)) {
    mean <- 0 
  }
  if (is.null(sd)) {
    sd <- 1
  }
  if (length(method)!= 1) {
    stop("invalid arguments")
  }
  c <- 0
  m_list <- c(1,2,3)
  for (i in 1:3) {
    if (method == m_list[i]) {
      c <- c+1
    }
  }
  if (c != 1) {
    stop("invalid arguments")
  }
# Function for Marsaglia and Bray algorithm
  my.rnorm=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      stop("invalid arguments")
    }
    if (length(mean)!= 1) {
      stop("invalid arguments")
    }
    if (length(sd) != 1) {
      stop("invalid arguments")
    }
    if (sd <= 0) {
      stop("invalid arguments")
    }
    n_reps <- n/2
    if (!(n_reps == round(n_reps))) {
      stop("invalid arguments")
    }
    list_1 <- c()
    list_2 <- c()
    while (length(list_1) < n) {
      a <- runif(2)
      for (i in 1:2) {
        a[i] <- 2*a[i] - 1
      }
      w <- a[1]^2 + a[2]^2 
      if (w <= 1) {
        v <- sqrt((-2*log(w))/w)
        list_1 <- c(list_1,a)
        list_2 <- c(list_2,v)
      }
    }
    list_1[1] <- list_1[1] * list_2[1]
    for (i in 2:n) {
      list_1[i] <- list_1[i] * list_2[floor(i/2)]
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
# Function for Box and Mueller Algorithm
  bm.rnorm=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      stop("invalid arguments")
    }
    if (length(mean)!= 1) {
      stop("invalid arguments")
    }
    if (length(sd) != 1) {
      stop("invalid arguments")
    }
    if (sd <= 0) {
      stop("invalid arguments")
    }
    n_reps <- n/2
    if (!(n_reps == round(n_reps))) {
      stop("invalid arguments")
    }
    list_1 <- c()
    while (length(list_1) < n) {
      a <- runif(2)
      a[1] <- sin(2*pi*a[1])*sqrt(-2*log(a[1]))
      a[2] <- cos(2*pi*a[2])*sqrt(-2*log(a[2]))
      list_1 <- c(list_1,a)
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
# Function for the central-limit theorem algorithm
  clt.rnorm=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      stop("invalid arguments")
    }
    if (length(mean)!= 1) {
      stop("invalid arguments")
    }
    if (length(sd) != 1) {
      stop("invalid arguments")
    }
    if (sd <= 0) {
      stop("invalid arguments")
    }
    if (!(n == round(n))) {
      stop("invalid arguments")
    }
    list_1 <- c()
    while (length(list_1) < n) {
      for (i in 1:n) {
        a <- runif(16)
        b <- (sum(a)-8)*sqrt(12/16)
        list_1 <- c(list_1,b)
      }
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
  if (method == 1) {
    return(my.rnorm(n,mean,sd))
  }
  if (method == 2) {
    return(bm.rnorm(n,mean,sd))
  }
  if (method == 3) {
    return(clt.rnorm(n,mean,sd))
  } 
}

# Purpose:
#       my.rnorm.ad is an adapted version of my.rnorm, the only difference is the 
#       stop statements in my.rnorm are return statements in my.rnorm.ad so that 
#       my test isn't stopped when checking that errors in arguments are caught. 
#       I will use this in place of my.rnorm in my test
#
# Input:
#       n - an even integer for the number of desired random numbers
#       mean - a scalar for the desired mean, default 0
#       sd - a positive scalar for the desired standard deviation, default 1
#
# Output:
#      A vector of length n containing the normally distributed random numbers 
#      generated by the method or "invalid arguments" if a stop would have
#      occured in my.rnorm

my.rnorm.ad=function(n,mean=NULL,sd=NULL) {
  if (is.null(mean)) {
    mean <- 0 
  }
  if (is.null(sd)) {
    sd <- 1
  }
  if (length(n)!= 1) {
    return("invalid arguments")
  }
  if (length(mean)!= 1) {
    return("invalid arguments")
  }
  if (length(sd) != 1) {
    return("invalid arguments")
  }
  if (sd <= 0) {
    return("invalid arguments")
  }
  n_reps <- n/2
  if (!(n_reps == round(n_reps))) {
    return("invalid arguments")
  }
  list_1 <- c()
  list_2 <- c()
  while (length(list_1) < n) {
    a <- runif(2)
    for (i in 1:2) {
      a[i] <- 2*a[i] - 1
    }
    w <- a[1]^2 + a[2]^2 
    if (w <= 1) {
      v <- sqrt((-2*log(w))/w)
      list_1 <- c(list_1,a)
      list_2 <- c(list_2,v)
    }
  }
  list_1[1] <- list_1[1] * list_2[1]
  for (i in 2:n) {
    list_1[i] <- list_1[i] * list_2[floor(i/2)]
  }
  if (sd != 1) {
    list_1 <- list_1 * sd
  }
  if (mean != 0) {
    list_1 <- list_1 + mean
  }
  return(list_1)
}

# Purpose:
#       general.rnorm.ad is an adapted version of general.rnorm. It is adapted in
#       the same way as my.rnorm.ad, stop statements changed to return statements
#       for the same reason that my.rnorm was adapted to my.rnorm.ad and will be
#       used in my test instead of general.rnorm
#
# Input:
#       n - an even integer for the number of desired random numbers
#       mean - a scalar for the desired mean, default 0
#       sd - a positive scalar for the desired standard deviation, default 1
#
# Output:
#      A vector of length n containing the normally distributed random numbers 
#      generated by the method or "invalid arguments" if a stop would have
#      occured in my.rnorm

general.rnorm.ad=function(n,mean=NULL,sd=NULL,method=NULL) {
  if (is.null(method)) {
    method <- 1
  }
  if (is.null(mean)) {
    mean <- 0 
  }
  if (is.null(sd)) {
    sd <- 1
  }
  if (length(method)!= 1) {
    return("invalid arguments")
  }
  c <- 0
  m_list <- c(1,2,3)
  for (i in 1:3) {
    if (method == m_list[i]) {
      c <- c+1
    }
  }
  if (c != 1) {
    return("invalid arguments")
  }
# Adapted version of my.rnorm (Marsaglia and Bray algorithm)
  my.rnorm.ad=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      return("invalid arguments")
    }
    if (length(mean)!= 1) {
      return("invalid arguments")
    }
    if (length(sd) != 1) {
      return("invalid arguments")
    }
    if (sd <= 0) {
      return("invalid arguments")
    }
    n_reps <- n/2
    if (!(n_reps == round(n_reps))) {
      return("invalid arguments")
    }
    list_1 <- c()
    list_2 <- c()
    while (length(list_1) < n) {
      a <- runif(2)
      for (i in 1:2) {
        a[i] <- 2*a[i] - 1
      }
      w <- a[1]^2 + a[2]^2 
      if (w <= 1) {
        v <- sqrt((-2*log(w))/w)
        list_1 <- c(list_1,a)
        list_2 <- c(list_2,v)
      }
    }
    list_1[1] <- list_1[1] * list_2[1]
    for (i in 2:n) {
      list_1[i] <- list_1[i] * list_2[floor(i/2)]
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
# Adapted version of bm.rnorm (Box and Mueller algorithm)
  bm.rnorm.ad=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      return("invalid arguments")
    }
    if (length(mean)!= 1) {
      return("invalid arguments")
    }
    if (length(sd) != 1) {
      return("invalid arguments")
    }
    if (sd <= 0) {
      return("invalid arguments")
    }
    n_reps <- n/2
    if (!(n_reps == round(n_reps))) {
      return("invalid arguments")
    }
    list_1 <- c()
    while (length(list_1) < n) {
      a <- runif(2)
      a[1] <- sin(2*pi*a[1])*sqrt(-2*log(a[1]))
      a[2] <- cos(2*pi*a[2])*sqrt(-2*log(a[2]))
      list_1 <- c(list_1,a)
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
# Adapted version of clt.rnorm (Central-limit theorem algorithm)
  clt.rnorm.ad=function(n,mean=NULL,sd=NULL) {
    if (is.null(mean)) {
      mean <- 0 
    }
    if (is.null(sd)) {
      sd <- 1
    }
    if (length(n)!= 1) {
      return("invalid arguments")
    }
    if (length(mean)!= 1) {
      return("invalid arguments")
    }
    if (length(sd) != 1) {
      return("invalid arguments")
    }
    if (sd <= 0) {
      return("invalid arguments")
    }
    if (!(n == round(n))) {
      return("invalid arguments")
    }
    list_1 <- c()
    while (length(list_1) < n) {
      for (i in 1:n) {
        a <- runif(16)
        b <- (sum(a)-8)*sqrt(12/16)
        list_1 <- c(list_1,b)
      }
    }
    if (sd != 1) {
      list_1 <- list_1 * sd
    }
    if (mean != 0) {
      list_1 <- list_1 + mean
    }
    return(list_1)
  }
  if (method == 1) {
    return(my.rnorm.ad(n,mean,sd))
  }
  if (method == 2) {
    return(bm.rnorm.ad(n,mean,sd))
  }
  if (method == 3) {
    return(clt.rnorm.ad(n,mean,sd))
  } 
}

# Purpose:
#       To be used within general.rnorm.test. Function to test that my functions 
#       for the 3 different methods work correctly. Method 3 will fail test 2 in 
#       method.test, this is accounted for in test 6 of general.rnorm.test. 
# 
# Input:
#       m - Method (1,2,3)
#       t - how extensive the test is, given as argument of general.rnorm.test
#
# Output:
#       "Test Passed" - If all tests within method.test are passed
#       Binary vector, each element corresponding to a test, if one of the tests
#       is failed. Easy to identify where the function fails.
#       Histograms of D-values and p-values for 1000 Kolmagorov-Smirnov 
#       one-sample goodness of fit tests on 1000 generated values.

method.test=function(m,t) {
  even.list <- seq(2,(2*t),2)
  odd.list <- seq(1,(2*t),2)
  mean.list <- seq(-(t-1),t,1)
  sd.list <- c(1:t)
  sd.neg.list <- seq(-(t-1),0,1)
  vector.list <- c()
  decimal.list <- c()
  ks.D.list <- c()
  ks.p.list <- c()
  p1<-0
  p2<-0
  p3<-0
  p4<-0
  p5<-0
  p6<-0
  p7<-0
  p8<-0
  b <- 0
  d <- 0
  e <- 0
  f <- 0
  g <- 0
  h <- 0
  q <- 0
  r <- 0
  # Test 1: Checking function produces vector of correct length and type for even
  #         n and default mean and standard deviation
  for (i in 1:t) {
    a <- general.rnorm.ad(even.list[i],method=m)
    if (length(a) == 2*i & is.numeric(a)) {
      b <- b + 1
    }
  }
  if (b == t) {
    p1 <- p1 + 1
  }
  # Test 2: Checking function catches error when n is odd
  for (i in 1:t) {
    a <- general.rnorm.ad(n=odd.list[i],method=m)
    if (!(is.numeric(a))) {
      d <- d + 1
    }    
  }
  if (d == t) {
    p2 <- p2 + 1
  }
  # Test 3: Checking function produces vector of correct length and type for even
  #         n with non-default mean and standard deviation
  for (i in 1:t) {
    for (j in 1:t) {
      for (k in 1:t) {
        a <- general.rnorm.ad(even.list[i],mean.list[j],sd.list[k],method=m)
        if (length(a) == 2*i & is.numeric(a)) {
          e <- e + 1
        }
      }
    } 
  }
  if (e == t^3) {
    p3 <- p3 + 1
  }
  # Test 4: Checking function catches error when standard deviation is negative
  for (i in 1:t) {
    a <- general.rnorm.ad(n=10,sd=sd.neg.list[i],method=m)
    if (!(is.numeric(a))) {
      f <- f + 1
    }
  }
  if (f == t) {
    p4 <- p4 + 1
  }
  # Test 5: Checking function catches error when n is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- general.rnorm.ad(n=a,method=m)
    if (!(is.numeric(b))) {
      g <- g + 1
    }
  }
  if (g == t) {
    p5 <- p5 + 1
  }
  # Test 6: Checking function catches error when mean is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- general.rnorm.ad(n=10,mean=a,method=m)
    if (!(is.numeric(b))) {
      h <- h + 1
    }
  }
  if (h == t) {
    p6 <- p6 + 1
  }
  # Test 7: Checking function catches error when standard deviation is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- general.rnorm.ad(n=10,sd=a,method=m)
    if (!(is.numeric(b))) {
      q <- q + 1
    }
  }
  if (q == t) {
    p7 <- p7 + 1
  }
  # Test 8: Checking function catches error when n is not an integer
  for (i in 1:10) {
    a <- t + (1/(10^i))
    decimal.list <- c(decimal.list,a)
  }
  for (i in 1:10) {
    a <- decimal.list[i]
    b <- general.rnorm.ad(a,method=m)
    if (!(is.numeric(b))) {
      r <- r + 1
    }
  }
  if (r == 10) {
    p8 <- p8 + 1
  }
  # Test 9: Kolmagorov-Smirnov one-sample goodness of fit test with histograms 
  #         plotted to check for normality
  for (i in 1:1000) {
    a <- general.rnorm.ad(1000,0,1,method=m)
    ks <- ks.test(a,"pnorm",mean=0,sd=1)
    ks.D.list <- c(ks.D.list,ks[1])
    ks.p.list <- c(ks.p.list,ks[2])
  }
  par(mfrow=c(2,2))
  if (m == 1) {
    hist(a,xlab="Data",main="Histogram of Data, method 1")
    qqnorm(a)
    hist(as.numeric(ks.D.list),xlab="D-value",main="Histogram of D-values, method 1")
    hist(as.numeric(ks.p.list),xlab="p-value",main="Histogram of p-values, method 1")
  }
  if (m == 2) {
    hist(a,xlab="Data",main="Histogram of Data, method 2")
    qqnorm(a)
    hist(as.numeric(ks.D.list),xlab="D-value",main="Histogram of D-values, method 2")
    hist(as.numeric(ks.p.list),xlab="p-value",main="Histogram of p-values, method 2")
  }
  if (m == 3) {
    hist(a,xlab="Data",main="Histogram of Data, method 3")
    qqnorm(a)
    hist(as.numeric(ks.D.list),xlab="D-value",main="Histogram of D-values, method 3")
    hist(as.numeric(ks.p.list),xlab="p-value",main="Histogram of p-values, method 3")
  }
  if (sum(c(p1,p2,p3,p4,p5,p6,p7,p8)) == 8) {
    return("Test Passed")
  }
  else {
    return(c(p1,p2,p3,p4,p5,p6,p7,p8))
  }
}

# Purpose:
#       Completey automated test function for the my.rnorm function
#
#
# Input:
#       t - how extensive the test is, default 10
#
# Output:
#      "Test Passed" - If all tests within method.test are passed
#      Binary vector, each element corresponding to a test, if one of the tests
#      is failed. Easy to identify where the function fails.
#      Histograms of D-values and p-values for 1000 Kolmagorov-Smirnov 
#      one-sample goodness of fit tests on 1000 generated values. 

my.rnorm.test=function(t=NULL) {
  if (is.null(t)) {
    t <- 10
  }
  even.list <- seq(2,(2*t),2)
  odd.list <- seq(1,(2*t),2)
  mean.list <- seq(-(t-1),t,1)
  sd.list <- c(1:t)
  sd.neg.list <- seq(-(t-1),0,1)
  vector.list <- c()
  decimal.list <- c()
  ks.D.list <- c()
  ks.p.list <- c()
  p1<-0
  p2<-0
  p3<-0
  p4<-0
  p5<-0
  p6<-0
  p7<-0
  p8<-0
  b <- 0
  d <- 0
  e <- 0
  f <- 0
  g <- 0
  h <- 0
  q <- 0
  r <- 0
  # Test 1: Checking function produces vector of correct length and type for even
  #         n and default mean and standard deviation
  for (i in 1:t) {
    a <- my.rnorm.ad(even.list[i])
    if (length(a) == 2*i & is.numeric(a)) {
      b <- b + 1
    }
  }
  if (b == t) {
    p1 <- p1 + 1
  }
  # Test 2: Checking function catches error when n is odd
  for (i in 1:t) {
    a <- my.rnorm.ad(odd.list[i])
    if (!(is.numeric(a))) {
      d <- d + 1
    }    
  }
  if (d == t) {
    p2 <- p2 + 1
  }
  # Test 3: Checking function produces vector of correct length and type for even
  #         n with non-default mean and standard deviation
  for (i in 1:t) {
    for (j in 1:t) {
      for (k in 1:t) {
        a <- my.rnorm.ad(even.list[i],mean.list[j],sd.list[k])
        if (length(a) == 2*i & is.numeric(a)) {
          e <- e + 1
        }
      }
    } 
  }
  if (e == t^3) {
    p3 <- p3 + 1
  }
  # Test 4: Checking function catches error when standard deviation is negative
  for (i in 1:t) {
    a <- my.rnorm.ad(n=10,sd=sd.neg.list[i])
    if (!(is.numeric(a))) {
      f <- f + 1
    }
  }
  if (f == t) {
    p4 <- p4 + 1
  }
  # Test 5: Checking function catches error when n is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- my.rnorm.ad(a)
    if (!(is.numeric(b))) {
      g <- g + 1
    }
  }
  if (g == t) {
    p5 <- p5 + 1
  }
  # Test 6: Checking function catches error when mean is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- my.rnorm.ad(n=10,mean=a)
    if (!(is.numeric(b))) {
      h <- h + 1
    }
  }
  if (h == t) {
    p6 <- p6 + 1
  }
  # Test 7: Checking function catches error when standard deviation is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- my.rnorm.ad(n=10,sd=a)
    if (!(is.numeric(b))) {
      q <- q + 1
    }
  }
  if (q == t) {
    p7 <- p7 + 1
  }
  # Test 8: Checking function catches error when n is not an integer
  for (i in 1:10) {
    a <- t + (1/(10^i))
    decimal.list <- c(decimal.list,a)
  }
  for (i in 1:10) {
    a <- decimal.list[i]
    b <- my.rnorm.ad(a)
    if (!(is.numeric(b))) {
      r <- r + 1
    }
  }
  if (r == 10) {
    p8 <- p8 + 1
  }
  # Test 9: Kolmagorov-Smirnov one-sample goodness of fit test with histograms 
  #         plotted to check for normality
  for (i in 1:1000) {
    a <- my.rnorm.ad(1000,0,1)
    ks <- ks.test(a,"pnorm",mean=0,sd=1)
    ks.D.list <- c(ks.D.list,ks[1])
    ks.p.list <- c(ks.p.list,ks[2])
  }
  par(mfrow=c(2,2))
  hist(a,xlab="Data",main="Histogram of Data")
  qqnorm(a)
  hist(as.numeric(ks.D.list),xlab="D-value",main="Histogram of D-values")
  hist(as.numeric(ks.p.list),xlab="p-value",main="Histogram of p-values")
  if (sum(c(p1,p2,p3,p4,p5,p6,p7,p8)) == 8) {
    return("Test Passed")
  }
  else {
    return(c(p1,p2,p3,p4,p5,p6,p7,p8))
  }
}

# Purpose:
#       Completely automated testing function for the general.rnorm function
#       method.test function used within this function
#
# Input:
#       t - how extensive the test is, default 10
#
# Output:
#       "Test Passed" - If all tests within method.test are passed
#       Binary vector, each element corresponding to a test, if one of the tests
#       is failed. Easy to identify where the function fails.
#       Histograms of D-values and p-values for 1000 Kolmagorov-Smirnov 
#       one-sample goodness of fit tests on 1000 generated values for each method

general.rnorm.test=function(t=NULL) {
  if (is.null(t)) {
    t <- 10
  }
  ne.list <- c(4:(t+4))
  decimal.list <- c()
  d <- 0
  e <- 0
  f <- 0
  p1 <- 0
  p2 <- 0
  p3 <- 0
  p4 <- 0
  p5 <- 0
  p6 <- 0
  
  # Test 1: Check function catches error when method is a scalar but not an
  #         element of (1,2,3)
  for (i in 1:t) {
    a <- ne.list[i]
    b <- general.rnorm.ad(n=10,method=a)
    if (!(is.numeric(b))) {
      d <- d + 1
    }
  }
  if (d == t) {
    p1 <- p1 + 1
  }
  # Test 2: Check function catches error when method is a vector
  for (i in 2:(t+1)) {
    a <- c(1:i)
    b <- general.rnorm.ad(n=10,method=a)
    if (!(is.numeric(b))) {
      e <- e + 1
    }
  }
  if (e == t) {
    p2 <- p2 + 1
  }
  # Test 3: Check function catches error when method is not an integer
  for (i in 1:10) {
    a <- (1/(10^i))
    decimal.list <- c(decimal.list,a)
  }
  for (i in 1:10) {
    for (j in 1:3) {
      a <- j + decimal.list[i]
      b <- general.rnorm.ad(n=10,method=a)
      if (!(is.numeric(b))) {
        f <- f + 1
      }
    }
  }
  if (f == 30) {
    p3 <- p3 + 1
  }
  # Test 4: Check function passes method.test when method is 1
  m <- 1
  a <- method.test(m,t)
  if (!(is.numeric(a))) {
    p4 <- p4 + 1
  }
  # Test 5: Check function passes method.test when method is 2
  m <- 2
  a <- method.test(m,t)
  if (!(is.numeric(a))) {
    p5 <- p5 + 1
  }
  # Test 6: Check function only fails test 2 in method.test when method is 3, hence
  #         allowing odd n values when using the central limit theorem method
  m <- 3
  a <- method.test(m,t)
  if (sum(a)==7 & a[2]==0) {
    p6 <- p6 + 1
  }
  if (sum(c(p1,p2,p3,p4,p5,p6)) == 6) {
    return("Test Passed")
  }
  else {
    return(c(p1,p2,p3,p4,p5,p6))
  }
}
