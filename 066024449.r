#Final Assessment 1

# I confirm that the attached is my own work, except  where clearly indicated
# in the text


# Marsaglia Bray algorithm


marsaglia.bray <- function() { # defines a function marsaglia.bray() with no arguments
    repeat {
      a <- runif(2, 0, 1)      # generates a pair of uniform deviates
      u1 <- 2*(a[1]) -1        # transforms u1 and u2 to unit square
      u2 <- 2*(a[2]) -1
      w <-u1^2 + u2^2          # calculates w
    if (w <= 1) break          # repeats this process until w returns a value <=1
    }
    v <- sqrt((-2*log(w))/w)   # calculates v
    x1 <- u1*v                 # uses v to calculate x1 and x2
    x2 <- u2*v
  return(list(x1,x2))          # returns x1 and x2 in a list
}

#Box-Mueller algorithm


box.mueller <- function() {               # defines a function box.mueller() 
  b <- runif(2,0,1)                       # generates a pair of uniform deviates
  x1 <- sin(2*pi*b[1])*sqrt(-2*log(b[2])) # calculates x1 and x2
  x2 <- cos(2*pi*b[1])*sqrt(-2*log(b[2]))
 return(list(x1,x2))                      # returns x1 and x2 in a list
}

#adapted version for use in general.rnorm (allows for even n != 2)

box.mueller2 <- function(n, mean=0, sd=1) { 
  x <- vector(mode="numeric", length=n) # creates vector of 0s length n
  for (i in seq(1,n/2)) {               # note (n/2) in place of (n) as a generates pairs
    a <- box.mueller()                  
    x[2*i -1] <- a[[1]]*sd + mean       # 1st element of each pair assigned to (2*i -1)th element x
    x[2*i]<- a[[2]]*sd + mean           # 2nd element of each pair assigned to (2*i)th element of x
  }
  return(x)
}

# Central Limit Theorem

central.limit <- function() {           # defines a function central.limit()
  c <- runif(16,0,1)                    # generates 16 uniform deviates
  x <- (sum(c) - 8)*sqrt(12/16)         # calculates x using the sum of c
  return(x)                             # returns the value of x
}

# adapted version for use in general.rnorm

central.limit2 <- function(n, mean=0, sd=1) {
  x <- replicate(n, central.limit())    # calculates n such x values generated by central.limit
  return(x)
}
  

# my.rnorm
# define a function my.rnorm
my.rnorm <- function(n, mean=0, sd=1) {
  x <- vector(mode="numeric", length=n) # creates an empty vector of 0s, length n
  for (i in seq(1,n/2)) {               # note (n/2) in place of (n) as a generates pairs
    a <- marsaglia.bray()
    x[2*i -1] <- a[[1]]*sd + mean       # 1st element of each pair assigned to (2*i -1)th element x
    x[2*i]<- a[[2]]*sd + mean           # 2nd element of each pair assigned to (2*i)th element of x
  }
  return(x)                             # return a vector x of n pseudo-random normally distributed deviates
}

# my.rnorm will only successfully calculate n variables when n is even.
# if n is an odd number, n/2 in (seq(1,n/2)) is not an integer.
# R can therefore only produce n-1 values.

# general.rnorm  
# defines a function general.rnorm with added argument (method)
  
general.rnorm <- function(n, mean=0, sd=1, method=1){ # default method is 1
  if (method == 1) {                                  # if method = 1, executes my.rnorm as before
   x <- my.rnorm(n, mean, sd)
  } else if (method == 2) {
   x <- box.mueller2(n, mean, sd)                     # else executes box.muller2()
  } else if (method == 3) {
   x <- central.limit2(n, mean, sd)                   # else executes central.limit2()
  }
  return(x)   # return a vector x of n pseudo-random normally distributed deviates
}

# Test functions
# tests whether the mean and sd output of the function my.rnorm are close to the values of mean and 
# sd in the arguments of my.rnorm
# can change n, mean and sd and compare mean and sd to m and s.

test.my.rnorm <- function(n, mean=0, sd=1) {
  x <- my.rnorm(n, mean, sd)
  m <- mean(x)
  s <- sd(x)
  return(list(m,s))
}
